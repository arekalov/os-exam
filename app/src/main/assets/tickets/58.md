---
number: 58
title: Буферизация ввода-вывода. Ввод-вывод UNIX SVR4
---


## Виды буферизации
* **Без буферизации** - данные по DMA сразу попадают из контроллера в пользовательское АП. Максимально быстро, но опасно при вытесняющией многозадачности и свопинге, поэтому страница часто лочится в памяти
* **Одиночная буферизация** - сначала блок читается в буфер ядра, затем копируется в пользовательскую страницу. Копирование по времени мало по сравнению с самом дискоровым вводом-выводом, но зато защищает от проблем со свопингом и дает возможность перекрывать вычисления и ввод-вывод
* **Двойная буферизация** - в ядре 2 буфера, используемые по очереди устройством и процессом. Пока процесс копирует и обрабатывает данные из одного буфера, устройство заполняет второй буфер следующией инфой
* **Кольцевая буферизация**  - несоклько буфером, организованных как кольцевой буфер, реализующий паттерн producer-customer. Устройство (producer) последовательно кладет блоки в кольцо, двигая хвост, процесс (customer) забирает готовые блоки, двигая голову

## Буферизация для разных устройств
* **Блочные** устройства (диски) отдельно работают блоками (сектор/блок) и выигрывают от буферного кэша, особенно при последовательном доступе и многократном чтении тех же блоков
* **Символьные** устройства (терминалы, последовательные порты) чаще исползуют небольшие внутренние буферы в драйвере, а не общий блочный кэш, потому что перируют потоком байт, а не дисковыми блоками

## Ввод-вывод в SVR4

![](images/58_io_svr4.png)
UNIX SVR4 используцет классическую схему буферного кэша для дисковых устройств
* Есть подсистема буфером (buffer cache) и отдельная подсистема io (buffered IO), где буферы организованы списками (free list) и хэш-таблицей с ключом "устройство + номер блока" для быстрого поиска уже прочитанных блоков
* Когда буфер устаревает или память заканчивается, применяется политка вытеснения LRU: старые буферы уходят в free list и могут быть перераспределны под новые блоки

### Для дисков различают:
* Блочные устройства - используют ФС и буферный кэш, все запросы к файлам в итоге проходят через буферный IO и буферы кэша
* Сырые (raw) устройства - обходят кэш и соответствуют режиму без буферизации: данные идут напрямую между контроллером и страницами процесса, а ядро блокирует жэти страницы для продотвращения выгрузки
